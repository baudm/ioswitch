#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
% for subfigures/subtables
\ifCLASSOPTIONcompsoc
\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\else
\usepackage[caption=false,font=footnotesize]{subfig}
\fi
\end_preamble
\use_default_options false
\language english
\inputencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement tbh
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Your Title"
\pdf_author "Your Name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
You find the IEEEtran document class documentation here: http://mirror.ctan.org/ma
cros/latex/contrib/IEEEtran/IEEEtran_HOWTO.pdf
\end_layout

\end_inset


\end_layout

\begin_layout Title

\size huge
Workload-dependent Dynamic I/O Scheduler Selection
\end_layout

\begin_layout Author
Jermaine Luis M.
 Agnasin, Mark Earvin V.
 Alba, Thomas Neil P.
 Balauag, Darwin M.
 Bautista
\end_layout

\begin_layout MarkBoth
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

Your Name 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
MakeLowercase{
\end_layout

\end_inset


\emph on
et al.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\emph default
: Your Title
\begin_inset Note Note
status open

\begin_layout Plain Layout
left side
\series bold
}{
\series default
right side
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Since there is no I/O scheduler that can be optimal for all types of workload,
 changing the I/O scheduler to suite the current workload would yield better
 overall system performance.
 This study aims to implement a dynamically-tuned kernel that switches the
 I/O scheduler based on the current workload.
 The workloads are defined as Sequential I/O and Random I/O
\end_layout

\begin_layout Keywords
I/O scheduling, workload characterization
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The 
\series bold

\backslash
IEEEPARstart
\series default
 command is needed in the first paragraph fo the document.
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEPARstart{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

omputer
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 hardware has been generally improving over the past decades.
 However, I/O-related hardware has not been able to cope with the advances
 in CPU technology.
 In a computer, the I/O system is often the performance bottleneck.
 Thus, being able to utilize the full capacity of a computer's I/O hardware
 is the key to achieving optimum system performance.
\end_layout

\begin_layout Standard
Most Linux users run different types of programs.
 Some use their computers as web servers or routers and as desktop workstations
 as well.
 Other users also run desktop applications but leave their computers while
 compiling a kernel or a big application.
 In other words, workload characteristics of computers vary from time to
 time.
 With that said, kernels optimized for a specific workload would be suboptimal.
 Tuning the kernel on-the-fly is what modern users would need.
\end_layout

\begin_layout Standard
The I/O scheduler is the part of the kernel that decides which request (read
 or write) should be performed next.
 The Linux kernel has a choice of four schedulers, but most distributions
 use the default Completely Fair Queuing (CFQ) scheduler for their desktop
 kernels.
 It has been the default in Linux since version 2.6.18.
 It is generally a recommendable all-round scheduler which offers suitable
 performance in sharing drive access between all the different processes
 that are trying to access the drive at the same time.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Some common I/O scheduler goals are:
\end_layout

\begin_layout Itemize
To minimize time wasted by hard disk seeks.
\end_layout

\begin_layout Itemize
To prioritize a certain process' I/O requests.
\end_layout

\begin_layout Itemize
To give a share of the disk bandwidth to each running process.
\end_layout

\begin_layout Itemize
To guarantee that certain requests will be serviced before a particular
 deadline.
\end_layout

\begin_layout Standard
Since no single I/O scheduler can be optimal for all types of workloads,
 changing the I/O scheduler to suit the current workload would yield better
 overall system performance.
\end_layout

\begin_layout Standard
We aim to develop a dynamic I/O scheduler switcher based on defined workloads.
 The I/O scheduler selected by the dynamic switcher should deliver the best
 performance, in terms of throughput, for the current workload.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
This chapter provides a review of prior work related to this study.
 Both prior research deal with I/O optimization via automatic I/O scheduler
 selection based on statistics.
\end_layout

\begin_layout Subsection
Automatic I/O Scheduler Selection
\end_layout

\begin_layout Standard
Linux provides four I/O schedulers to meet different workload requirements.
 Among them are the Deadline Scheduler which is useful for real-time workloads
 and the Completely Fair Queuing (CFQ) which distribute the available I/O
 bandwidth among processes equally.
 At boot time, only one of these schedulers is selected and applied to all
 drives in the system.
 To achieve optimal performance, the scheduler must exploit the current
 workload characteristics, e.g.
 throughput and fairness.
 The Linux kernel provides an interface where the user can switch among
 these schedulers.
 However, to do so would require expertise on I/O performance.
 ADIO provides a method to automate scheduler selection based on system
 characteristics and current workload 
\begin_inset CommandInset citation
LatexCommand cite
key "key-2"

\end_inset

.
\end_layout

\begin_layout Standard
The main criteria for this proposed selection is bounded latency and throughput.
 At first, the Automatic and Dynamic I/O scheduler (ADIO) algorithm chooses
 between CFQ and Deadline and ensures that the maximum request latency is
 bounded.
 If it is, it prioritizes throughput.
 This optimization is done using feedback-based control and the I/O scheduler
 component called Dynamic and Adaptive Scheduler Selector (DASS).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/adio.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ADIO Architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The DASS is consist of two components, the request statistics collection
 monitor and the I/O scheduler selection controller.
 The request statistics collection monitor collects the maximum latency
 for read and write requests based on I/O arrivals from workloads and the
 number of read and write requests serviced .
 The statistics is recorded and is then used by the controller to determine
 which scheduler should be active to accommodate latency and bandwidth guarantee
s.
 The controller does this every adaptation period W.
 In the event of process deadline expiration, the controller switches from
 CFQ to deadline.
 However, to prevent frequent switching due to I/O burst, a switch is triggered
 only if at least two process did not meet their deadlines.
 For deadline to CFQ switch, the requirement is for the maximum latency
 to be below 50% of the upper bound.
\end_layout

\begin_layout Standard
Swapping is done by clearing the current scheduler queues and initializing
 the new scheduler queue.
 The drained queue is re-queued in the new scheduler.
 For large numbers of requests, this can incur a considerable overhead but
 does not impact the utilization of the system.
\end_layout

\begin_layout Subsection
Dynamic Disk Scheduling Algorithm
\end_layout

\begin_layout Standard
Most I/O scheduler employ algorithms which are best suited for a particular
 pattern of disk accesses.
 Some work best for sequential access, others for random activity, and others
 attempt to provide the best overall throughput and provide reasonable performan
ce for both sequential and random accesses.
\end_layout

\begin_layout Standard
If these patterns of disk accesses could be detected in real-time, then
 the system could select the disk scheduling algorithm best suited to this
 workload, and improve performance accordingly.
 This is the basis of the I/O Analyzer (IOAZ).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ioaz.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IOAZ Architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The researcher first analyzed what the best I/O scheduler for a specific
 workload is.
 The results of the experiment were used as the basis for decision matrices
 to be used by IOAZ in determining which disk scheduling algorithm to use
 given observations of system workload and an optimization goal.
\end_layout

\begin_layout Standard
The researcher used MySQL and the included sql-bench to test the IOAZ's
 performance as compared to static I/O scheduler.
 The researcher also conducted disk zeroing experiment wherein one gigabyte
 partition was overwritten with zeroes in a sequential fashion in a single
 pass.
 In both tests, IOAZ performed better compared to static I/O scheduler.
\end_layout

\begin_layout Section
Methodology
\end_layout

\begin_layout Subsection
Workload Characterization
\end_layout

\begin_layout Standard
We define two types of workloads based on I/O access patterns.
 The I/O scheduler would be changed depending on the currently identified
 workload.
\end_layout

\begin_layout Standard
The first type is the Sequential I/O workload.
 In Sequential I/O, the physical disks spend most of their time scanning
 a range of data clustered together in the same part of the disk.
 This type of access pattern results in high data transfer per I/O request.
 The Sequential I/O workload is exhibited mainly by file servers, database
 servers, and streaming media servers 
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"

\end_inset

.
\end_layout

\begin_layout Standard
The other type is the Random I/O workload.
 In this type of workload, the physical disks spend a measurable percentage
 of time seeking data from various different parts of the disk for read
 or write purposes.
 Thus, this type of access pattern results in relatively lower data transfer
 per I/O request, compared to Sequential I/O.
 Random I/O workload is often displayed by web servers, and mail servers
 
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"

\end_inset

.
 Since desktop workstations tend to be used for various tasks, desktop workload
 can be considered as either Sequential or Random.
\end_layout

\begin_layout Standard
Linux provides I/O statistics per disk.
 In recent 2.6 kernels, the I/O statistics are exported into userspace via
 sysfs.
 It can be accessed via 
\series bold
/sys/block/
\emph on
<device>
\emph default
/stat
\series default
.
 The I/O statistics currently available at the block layer include 
\emph on
read I/Os
\emph default
, 
\emph on
read sectors
\emph default
, 
\emph on
write I/Os
\emph default
, 
\emph on
write sectors
\emph default
, and other statistics .
 As stated earlier, the two workloads, Sequential I/O and Random I/O, can
 be differentiated from each other by looking at the ratio of data transferred
 to the number of I/O requests.
 Thus, the statistics on the 
\emph on
number of I/O requests processed
\emph default
 (
\emph on
read I/Os
\emph default
 + 
\emph on
write I/Os
\emph default
) and the 
\emph on
number of sectors accessed
\emph default
 (
\emph on
read sectors
\emph default
 + 
\emph on
write sectors
\emph default
) can be used for determining the current workload.
 Note that the statistics on 
\emph on
number of sectors accessed
\emph default
 is independent on the hardware and filesystem used because it is based
 on the standard 512-byte sector in UNIX.
 As such, it can be readily used for this project's purposes.
 Also, for the statistics to be useful, minimal filesystem fragmentation
 is assumed.
 The remaining concern now is being able to draw a line between what is
 Sequential and what is Random based on the ratio of 
\emph on
sectors accessed
\emph default
 to 
\emph on
I/O requests processed
\emph default
.
\end_layout

\begin_layout Subsection
Statistics Processing
\end_layout

\begin_layout Standard
We patterned the statistics processing with the CPU load computation of
 Linux.
 
\family typewriter
calc_load()
\family default
 function, used to calculate CPU load, employs exponential moving average.
 The exponential moving average is a type of finite impulse response filter
 that applies weighting factor that decreases exponentially.
 The weighting for each older data point decreases exponentially, never
 reaching zero.
\end_layout

\begin_layout Standard
In our implementation, we used a 1-minute time window so that the output
 of 
\family typewriter
calc_load()
\family default
 stays responsive yet resilient against I/O bursts.
\end_layout

\begin_layout Subsection
I/O Scheduler Switcher
\end_layout

\begin_layout Standard
To minimize the in-kernel changes and ease development, the stock Ubuntu
 2.6.32 kernel was modified.
 We created a new function, 
\family typewriter
elv_switch()
\family default
, which is based on 
\family typewriter
elv_iosched_store()
\family default
, for changing the I/O scheduler.
 This function is 
\emph on
exported
\emph default
 using 
\family typewriter
EXPORT_SYMBOL()
\family default
 so that it can be used in kernel modules.
\end_layout

\begin_layout Standard
The scheduler switcher will be implemented as a kernel module.
 On load, it will spawn a kthread that would periodically look at the I/O
 statistics and determine the current workload.
 Once the current workload is determined, it would select the appropriate
 I/O scheduler (if needed).
 Based on related research, we have determined that the best I/O scheduler
 for Sequential I/O is 
\emph on
Anticipatory
\emph default
 while the best for Random I/O is 
\emph on
CFQ
\emph default
 for single-disk systems 
\begin_inset CommandInset citation
LatexCommand cite
key "key-4"

\end_inset

.
\end_layout

\begin_layout Section*
Appendix A: Gantt Chart
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/gantt-chart.png
	scale 43

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

C.H Lunde, H.
 Espeland, H.
 Stensland, A.
 Petlund, and P.
 Halvorsen.
 
\begin_inset Quotes eld
\end_inset

Improving Disk I/O Performance on Linux,” in 
\shape italic
Proc.
 Linux-Kongress and OpenSolaris Developer Conference
\shape default
, 2009, pp.
 61-70.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

S.
 Seelam, J.
 S.
 Babu, and P.
 Teller.
 “Automatic I/O Scheduler Selection for Latency and Bandwidth Optimization,”
 in 
\shape italic
Proc.
 Workshop on Operating System Interference in High Performance Applications
\shape default
, 2005.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

D.
 Hoch.
 “Extreme Linux Performance Monitoring Part II.” Internet: http://www.ufsdump.org/p
apers/io-tuning.pdf, Jan.
 15, 2007 [Sep.
 16, 2010].
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"

\end_inset

S.
 Pratt and D.
 Heger, “Workload Dependent Performance Evaluation of the Linux 2.6 I/O Scheduler
s,” in 
\shape italic
Proc.
 Ottawa Linux Symposium
\shape default
, 2004, pp.
 425-448.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset

D.
 L.
 Martens and M.
 J.
 Katchabaw, “Optimizing System Performance through Dynamic Disk Scheduling
 Algorithm Selection,” in 
\shape italic
Proc.
 WSEAS Trans.
 Information Science and Applications
\shape default
, 2006.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset

K.
 Brandt.
 
\begin_inset Quotes eld
\end_inset

Interpreting iostat Output.
\begin_inset Quotes erd
\end_inset

 Internet: http://blog.serverfault.com/post/777852755/interpreting-iostat-output,
 Jul.
 6, 2010 [Sep.
 16, 2010].
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Remember though that your final submission is supposed to have all the bibliogra
phy entries embedded in the LaTeX-file.
 This means you eventually have to copy the .bbl file into the latex file
 and remove the bibtex lines.
\end_layout

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\end_body
\end_document
